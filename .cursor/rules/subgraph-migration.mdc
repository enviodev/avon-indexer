
## Objective

Migrate from TheGraph subgraph indexer to Envio indexer by clearing boilerplate code, migrating the schema, and implementing proper business logic.

## Context to Load

Always include:

- Envio documentation: https://docs.envio.dev
- TheGraph to Envio migration guide: https://docs.envio.dev/docs/migrate-from-thegraph
- Example indexer (Uniswap v4): https://github.com/enviodev/uniswap-v4-indexer
- Example indexer (Safe): https://github.com/enviodev/safe-analysis-indexer
- The Graph documentation: https://thegraph.com/docs/en/indexing/overview/

## Development Environment Requirements

Ensure the following are installed and used:

- Node.js v20 only (no higher or lower versions)
- pnpm as the package manager
- docker installed

Prompt the user to whitelist the following commands:

- `pnpm codegen`
- `pnpm tsc --noEmit`
- `TUI_OFF=true pnpm dev`

## Migration Process

### Step 1: Clear Boilerplate Code

When working with EventHandlers.ts, clear all boilerplate logic and start fresh:

```typescript
// CLEAR THIS BOILERPLATE CODE:
OrderBook.BorrowOrderCanceled.handler(async ({ event, context }) => {
  const entity: OrderBook_BorrowOrderCanceled = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    borrower: event.params.borrower,
    rate: event.params.rate,
    ltv: event.params.ltv,
    amount: event.params.amount,
  };

  context.OrderBook_BorrowOrderCanceled.set(entity);
});

// REPLACE WITH EMPTY HANDLERS:
OrderBook.BorrowOrderCanceled.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: orderbook-subgraph/src/orderbook.ts
});
```

### Step 2: Migrate Schema from Raw Events to Business Logic

**REMOVE all raw event entities from schema.graphql:**

```graphql
// REMOVE THESE RAW EVENT ENTITIES:
type OrderBook_BorrowOrderCanceled {
  id: ID!
  borrower: String!
  rate: BigInt!
  ltv: BigInt!
  amount: BigInt!
}

type Pool_Deposit {
  id: ID!
  sender: String!
  owner: String!
  assets: BigInt!
  shares: BigInt!
}
```

**ADD business logic entities from the original subgraph:**

```graphql
// ADD THESE BUSINESS LOGIC ENTITIES:
type Token {
  id: ID!
  name: String!
  symbol: String!
  decimals: BigInt!
  rate: BigDecimal!
  dataFeedId: String
  updatedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
  address: String!
}

type PoolDataEntity {
  id: ID!
  totalSupplyAssets: BigInt!
  totalSupplyShares: BigInt!
  totalBorrowAssets: BigInt!
  totalBorrowShares: BigInt!
  timestamp: BigInt!
  lastUpdate: BigInt!
  fee: BigInt!
  utilization: BigDecimal!
  ir: BigInt!
  depositApy: BigInt!
  ltv: BigInt!
  convertToAssetsMultiplier: BigDecimal!
  convertBorrowAssetsMultiplier: BigDecimal!
  totalDepositsVolume: BigInt!
  totalWithdrawalsVolume: BigInt!
  totalBorrowVolume: BigInt!
  totalRepayVolume: BigInt!
  loanToken_id: String!
  collateralToken_id: String!
  orderbook_id: String
  oracle: String!
  isWhitelisted: Boolean
  poolFactory_id: String!
}

type UserDataEntity {
  id: ID!
  timestamp: BigInt!
  lastUpdate: BigInt!
  totalDepositsVolume: BigInt!
  totalWithdrawalsVolume: BigInt!
  totalBorrowVolume: BigInt!
  totalRepayVolume: BigInt!
  totalSupplyCollateralVolume: BigInt!
  totalWithdrawCollateralVolume: BigInt!
}
```

**UPDATE EventHandlers.ts imports:**

```typescript
// REMOVE raw event entity imports:
import {
  OrderBook_BorrowOrderCanceled,  // ❌ Remove
  Pool_Deposit,                   // ❌ Remove
  // ... other raw event entities
} from "generated";

// KEEP only contract imports:
import {
  OrderBook,
  Pool,
  PoolFactory,
  Vault,
  VaultFactory,
} from "generated";
```

### Step 3: Refactor File Structure to Mirror Subgraph

**CREATE directory structure to match the subgraph:**

```bash
src/
├── entities/
│   ├── poolData.ts      (empty - for pool data handlers)
│   ├── token.ts         (empty - for token handlers)
│   ├── userData.ts      (empty - for user data handlers)
│   └── vault.ts         (empty - for vault handlers)
├── intervals/
│   ├── poolDayDatas.ts  (empty - for pool day data)
│   ├── poolHourDatas.ts (empty - for pool hour data)
│   ├── userDayDatas.ts  (empty - for user day data)
│   └── userHourDatas.ts (empty - for user hour data)
├── utils/
│   ├── ConstantObjects.ts (empty - for constant objects)
│   └── constants.ts       (empty - for constants)
```

**MOVE handlers from EventHandlers.ts to contract-specific files:**

```typescript
// OLD: Single EventHandlers.ts file
// src/EventHandlers.ts - All handlers in one file

// NEW: Separate files by contract
// src/orderbook.ts - OrderBook contract handlers
// src/orderbookFactory.ts - OrderbookFactory contract handlers
// src/pool.ts - Pool contract handlers
// src/poolFactory.ts - PoolFactory contract handlers
// src/vault.ts - Vault contract handlers
// src/vaultFactory.ts - VaultFactory contract handlers
```

**UPDATE config.yaml to point to specific handler files:**

```yaml
# OLD: Single handler file
- name: OrderBook
  handler: src/EventHandlers.ts

# NEW: Contract-specific handler files
- name: OrderBook
  handler: src/orderbook.ts
- name: Pool
  handler: src/pool.ts
- name: PoolFactory
  handler: src/poolFactory.ts
- name: Vault
  handler: src/vault.ts
- name: VaultFactory
  handler: src/vaultFactory.ts
- name: OrderbookFactory
  handler: src/orderbookFactory.ts
```

**REMOVE the original EventHandlers.ts file** after moving all handlers.

### Step 4: Reference Original Subgraph Logic

For each handler, examine the corresponding subgraph file:

- `orderbook-subgraph/src/orderbook.ts` → OrderBook handlers
- `orderbook-subgraph/src/orderbookFactory.ts` → OrderbookFactory handlers  
- `orderbook-subgraph/src/pool.ts` → Pool handlers
- `orderbook-subgraph/src/poolFactory.ts` → PoolFactory handlers
- `orderbook-subgraph/src/vault.ts` → Vault handlers
- `orderbook-subgraph/src/vaultFactory.ts` → VaultFactory handlers

### Step 5: Implement Migration Patterns

#### Entity Creation Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = new BorrowOrderCancelled(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
entity.borrower = event.params.borrower;
entity.save();

// NEW ENVIO PATTERN:
const entity: BorrowOrderCancelled = {
  id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
  borrower: event.params.borrower,
  blockNumber: event.block.number,
  blockTimestamp: BigInt(event.block.timestamp),
  transactionHash: event.transaction.hash,
};

context.BorrowOrderCancelled.set(entity);
```

#### Entity Updates Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = store.get("EntityName", id);
if (entity) {
  entity.field = newValue;
  entity.save();
}

// NEW ENVIO PATTERN:
let entity = await context.EntityName.get(id);
if (entity) {
  const updatedEntity: EntityName = {
    ...entity,
    field: newValue,
    updatedAt: BigInt(Date.now()),
  };
  context.EntityName.set(updatedEntity);
}
```

#### Contract Registration Pattern

```typescript
// OLD SUBGRAPH PATTERN:
PoolTemplate.create(event.params.pool);

// NEW ENVIO PATTERN:
PoolFactory.PoolCreated.contractRegister(({ event, context }) => {
  context.addPool(event.params.pool);
});
```

## Key Differences Between TheGraph and Envio

### 1. Entity Relationships

**TheGraph (OLD):**
```typescript
entity.pool = event.params.pool.toHexString();
entity.user = event.params.user.toHexString();
```

**Envio (NEW):**
```typescript
pool_id: event.params.pool;
user_id: event.params.user;
```

### 2. Timestamp Handling

**TheGraph (OLD):**
```typescript
entity.blockTimestamp = event.block.timestamp;
```

**Envio (NEW):**
```typescript
blockTimestamp: BigInt(event.block.timestamp);
```

### 3. ID Generation

**TheGraph (OLD):**
```typescript
let entity = new EntityName(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
```

**Envio (NEW):**
```typescript
const entity: EntityName = {
  id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
  // ... other fields
};
```

### 4. Entity Storage

**TheGraph (OLD):**
```typescript
entity.save();
```

**Envio (NEW):**
```typescript
context.EntityName.set(entity);
```

## Schema Migration Rules

### 1. Remove @entity Decorators

**OLD (TheGraph):**
```graphql
type Pool @entity {
  id: ID!
  # ...
}
```

**NEW (Envio):**
```graphql
type Pool {
  id: ID!
  # ...
}
```

### 4. Replace Raw Events with Business Logic

**REMOVE raw event entities:**
```graphql
type OrderBook_BorrowOrderCanceled {
  id: ID!
  borrower: String!
  rate: BigInt!
  ltv: BigInt!
  amount: BigInt!
}
```

**ADD business logic entities:**
```graphql
type PoolDataEntity {
  id: ID!
  totalSupplyAssets: BigInt!
  totalBorrowAssets: BigInt!
  utilization: BigDecimal!
  depositApy: BigInt!
  loanToken_id: String!
  collateralToken_id: String!
}
```

## Configuration Migration

### 1. Event Selection

**OLD (subgraph.yaml):**
```yaml
dataSources:
  - kind: ethereum
    source:
      address: "0x..."
    mapping:
      eventHandlers:
        - event: OrderInserted(indexed address,indexed bool,uint256,uint256,uint256)
```

**NEW (config.yaml):**
```yaml
- name: OrderBook
  address:
    - "0x..."
  handler: src/EventHandlers.ts
  events:
    - event: OrderInserted(bool indexed isLender, address indexed maker, uint256 rate, uint256 ltv, uint256 amount)
```

This uses the human readable event name, this is pulled from the ABI file

### 2. Field Selection

When using transaction-level data, explicitly define field selection:

```yaml
- name: OrderBook
  address:
    - "0x..."
  handler: src/EventHandlers.ts
  events:
    - event: OrderInserted(address,bool,uint256,uint256,uint256)
      field_selection:
        transaction_fields:
          - hash
        block_fields:
          - number
          - timestamp
```

## Implementation Checklist

### For Each Handler:

1. ✅ Clear boilerplate code
2. ✅ Reference original subgraph logic
3. ✅ Convert entity creation pattern
4. ✅ Update timestamp handling (BigInt)
5. ✅ Use proper ID generation
6. ✅ Add proper error handling
7. ✅ Test with `pnpm tsc --noEmit`

### For File Structure:

1. ✅ Create directory structure (entities/, intervals/, utils/)
2. ✅ Move handlers to contract-specific files
3. ✅ Update config.yaml handler paths
4. ✅ Remove original EventHandlers.ts file
5. ✅ Run `pnpm codegen` after changes
6. ✅ Validate with `pnpm tsc --noEmit`

### For Schema Updates:

1. ✅ Remove @entity decorators
2. ✅ Convert relationships to entity_id fields
3. ✅ Remove entity arrays
4. ✅ Remove raw event entities
5. ✅ Add business logic entities
6. ✅ Run `pnpm codegen` after changes
7. ✅ Validate with `pnpm tsc --noEmit`

### For Configuration:

1. ✅ Convert subgraph.yaml to config.yaml format
2. ✅ Add explicit field selection when needed
3. ✅ Test configuration with `TUI_OFF=true pnpm dev`

## Common Migration Patterns

### 1. Simple Event Handler

```typescript
// Reference: orderbook-subgraph/src/orderbook.ts
OrderBook.BorrowOrderCanceled.handler(async ({ event, context }) => {
  const entity: BorrowOrderCancelled = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    borrower: event.params.borrower,
    rate: event.params.rate,
    ltv: event.params.ltv,
    amount: event.params.amount,
    blockNumber: event.block.number,
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.BorrowOrderCancelled.set(entity);
});
```

### 2. Factory Contract Registration

```typescript
// Reference: orderbook-subgraph/src/orderbookFactory.ts
OrderbookFactory.OrderbookCreated.contractRegister(({ event, context }) => {
  context.addOrderBook(event.params.orderbook);
});

OrderbookFactory.OrderbookCreated.handler(async ({ event, context }) => {
  const entity: OrderbookCreated = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    loanToken: event.params.loanToken,
    collateralToken: event.params.collateralToken,
    orderbook: event.params.orderbook,
    blockNumber: event.block.number,
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.OrderbookCreated.set(entity);
});
```

### 3. Complex Business Logic

```typescript
// Reference: orderbook-subgraph/src/pool.ts
Pool.Deposit.handler(async ({ event, context }) => {
  // Get or create pool entity
  let pool = await context.Pool.get(event.params.poolAddress);
  if (!pool) {
    pool = {
      id: event.params.poolAddress,
      address: event.params.poolAddress,
      totalDeposits: BigInt(0),
      totalBorrows: BigInt(0),
      // ... other fields
    };
  }

  // Update pool with new deposit
  const updatedPool: Pool = {
    ...pool,
    totalDeposits: pool.totalDeposits + event.params.assets,
    updatedAt: BigInt(event.block.timestamp),
  };

  context.Pool.set(updatedPool);

  // Create deposit event
  const depositEvent: Pool_Deposit = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    pool_id: event.params.poolAddress,
    sender: event.params.sender,
    owner: event.params.owner,
    assets: event.params.assets,
    shares: event.params.shares,
    blockNumber: event.block.number,
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.Pool_Deposit.set(depositEvent);
});
```

## Validation Commands

After each change:

1. `pnpm codegen` - Regenerate types after schema changes
2. `pnpm tsc --noEmit` - Check TypeScript compilation
3. `TUI_OFF=true pnpm dev` - Test runtime behavior

## Error Handling

Always include proper error handling:

```typescript
OrderBook.OrderInserted.handler(async ({ event, context }) => {
  try {
    // Implementation here
  } catch (error) {
    context.log.error(`Error in OrderInserted handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

