---
description: Improve the logic of the autogenerated indexer to align with a specific protocol's needs
globs: "**/*.{ts,js,res,graphql,yaml}"
alwaysApply: true
---

## Objective

Migrate from TheGraph subgraph indexer to Envio indexer by clearing boilerplate code and implementing proper business logic.

## Context to Load

Always include:

- Envio documentation: https://docs.envio.dev
- TheGraph to Envio migration guide: https://docs.envio.dev/docs/migrate-from-thegraph
- Example indexer (Uniswap v4): https://github.com/enviodev/uniswap-v4-indexer
- Example indexer (Safe): https://github.com/enviodev/safe-analysis-indexer

## Development Environment Requirements

Ensure the following are installed and used:

- Node.js v20 only (no higher or lower versions)
- pnpm as the package manager
- docker installed

Prompt the user to whitelist the following commands:

- `pnpm codegen`
- `pnpm tsc --noEmit`
- `TUI_OFF=true pnpm dev`

## Migration Process

### Step 1: Clear Boilerplate Code

When working with EventHandlers.ts, clear all boilerplate logic and start fresh:

```typescript
// CLEAR THIS BOILERPLATE CODE:
OrderBook.BorrowOrderCanceled.handler(async ({ event, context }) => {
  const entity: OrderBook_BorrowOrderCanceled = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    borrower: event.params.borrower,
    rate: event.params.rate,
    ltv: event.params.ltv,
    amount: event.params.amount,
  };

  context.OrderBook_BorrowOrderCanceled.set(entity);
});

// REPLACE WITH EMPTY HANDLERS:
OrderBook.BorrowOrderCanceled.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: orderbook-subgraph/src/orderbook.ts
});
```

### Step 2: Reference Original Subgraph Logic

For each handler, examine the corresponding subgraph file:

- `orderbook-subgraph/src/orderbook.ts` → OrderBook handlers
- `orderbook-subgraph/src/orderbookFactory.ts` → OrderbookFactory handlers
- `orderbook-subgraph/src/pool.ts` → Pool handlers
- `orderbook-subgraph/src/poolFactory.ts` → PoolFactory handlers
- `orderbook-subgraph/src/vault.ts` → Vault handlers
- `orderbook-subgraph/src/vaultFactory.ts` → VaultFactory handlers

### Step 3: Implement Migration Patterns

#### Entity Creation Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = new BorrowOrderCancelled(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
entity.borrower = event.params.borrower;
entity.save();

// NEW ENVIO PATTERN:
const entity: BorrowOrderCancelled = {
  id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
  borrower: event.params.borrower,
  blockNumber: event.block.number,
  blockTimestamp: BigInt(event.block.timestamp),
  transactionHash: event.transaction.hash,
};

await context.BorrowOrderCancelled.set(entity);
```

#### Entity Updates Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = store.get("EntityName", id);
if (entity) {
  entity.field = newValue;
  entity.save();
}

// NEW ENVIO PATTERN:
let entity = await context.EntityName.get(id);
if (entity) {
  const updatedEntity: EntityName = {
    ...entity,
    field: newValue,
    updatedAt: BigInt(Date.now()),
  };
  await context.EntityName.set(updatedEntity);
}
```

#### Contract Registration Pattern

```typescript
// OLD SUBGRAPH PATTERN:
PoolTemplate.create(event.params.pool);

// NEW ENVIO PATTERN:
PoolFactory.PoolCreated.contractRegister(({ event, context }) => {
  context.addPool(event.params.pool);
});
```

## Key Differences Between TheGraph and Envio

### 1. Entity Relationships

**TheGraph (OLD):**

```typescript
entity.pool = event.params.pool.toHexString();
entity.user = event.params.user.toHexString();
```

**Envio (NEW):**

```typescript
pool_id: event.params.pool;
user_id: event.params.user;
```

### 2. Timestamp Handling

**TheGraph (OLD):**

```typescript
entity.blockTimestamp = event.block.timestamp;
```

**Envio (NEW):**

```typescript
blockTimestamp: BigInt(event.block.timestamp);
```

### 3. ID Generation

**TheGraph (OLD):**

```typescript
let entity = new EntityName(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
```

**Envio (NEW):**

```typescript
const entity: EntityName = {
  id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
  // ... other fields
};
```

### 4. Entity Storage

**TheGraph (OLD):**

```typescript
entity.save();
```

**Envio (NEW):**

```typescript
context.EntityName.set(entity);
```

## Schema Migration Rules

### 1. Remove @entity Decorators

**OLD (TheGraph):**

```graphql
type Pool @entity {
  id: ID!
  # ...
}
```

**NEW (Envio):**

```graphql
type Pool {
  id: ID!
  # ...
}
```

## Configuration Migration

### 1. Event Selection

**OLD (subgraph.yaml):**

```yaml
dataSources:
  - kind: ethereum
    source:
      address: "0x..."
    mapping:
      eventHandlers:
        - event: OrderInserted(indexed address,indexed bool,uint256,uint256,uint256)
```

**NEW (config.yaml):**

```yaml
- name: OrderBook
  address:
    - "0x..."
  handler: src/EventHandlers.ts
  events:
    - event: OrderInserted(bool indexed isLender, address indexed maker, uint256 rate, uint256 ltv, uint256 amount)
```

This uses the human readable event name, this is pulled from the ABI file

### 2. Field Selection

When using transaction-level data, explicitly define field selection:

```yaml
- name: OrderBook
  address:
    - "0x..."
  handler: src/EventHandlers.ts
  events:
    - event: OrderInserted(address,bool,uint256,uint256,uint256)
      field_selection:
        transaction_fields:
          - hash
        block_fields:
          - number
          - timestamp
```

## Implementation Checklist

### For Each Handler:

1. ✅ Clear boilerplate code
2. ✅ Reference original subgraph logic
3. ✅ Convert entity creation pattern
4. ✅ Update timestamp handling (BigInt)
5. ✅ Use proper ID generation
6. ✅ Implement entity relationships with \_id fields
7. ✅ Add proper error handling
8. ✅ Test with `pnpm tsc --noEmit`

### For Schema Updates:

1. ✅ Remove @entity decorators
2. ✅ Convert relationships to entity_id fields
3. ✅ Remove entity arrays
4. ✅ Run `pnpm codegen` after changes
5. ✅ Validate with `pnpm tsc --noEmit`

### For Configuration:

1. ✅ Convert subgraph.yaml to config.yaml format
2. ✅ Add explicit field selection when needed
3. ✅ Test configuration with `TUI_OFF=true pnpm dev`

## Common Migration Patterns

### 1. Simple Event Handler

```typescript
// Reference: orderbook-subgraph/src/orderbook.ts
OrderBook.BorrowOrderCanceled.handler(async ({ event, context }) => {
  const entity: BorrowOrderCancelled = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    borrower: event.params.borrower,
    rate: event.params.rate,
    ltv: event.params.ltv,
    amount: event.params.amount,
    blockNumber: event.block.number,
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  await context.BorrowOrderCancelled.set(entity);
});
```

### 2. Factory Contract Registration

```typescript
// Reference: orderbook-subgraph/src/orderbookFactory.ts
OrderbookFactory.OrderbookCreated.contractRegister(({ event, context }) => {
  context.addOrderBook(event.params.orderbook);
});

OrderbookFactory.OrderbookCreated.handler(async ({ event, context }) => {
  const entity: OrderbookCreated = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    loanToken: event.params.loanToken,
    collateralToken: event.params.collateralToken,
    orderbook: event.params.orderbook,
    blockNumber: event.block.number,
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  await context.OrderbookCreated.set(entity);
});
```

### 3. Complex Business Logic

```typescript
// Reference: orderbook-subgraph/src/pool.ts
Pool.Deposit.handler(async ({ event, context }) => {
  // Get or create pool entity
  let pool = await context.Pool.get(event.params.poolAddress);
  if (!pool) {
    pool = {
      id: event.params.poolAddress,
      address: event.params.poolAddress,
      totalDeposits: BigInt(0),
      totalBorrows: BigInt(0),
      // ... other fields
    };
  }

  // Update pool with new deposit
  const updatedPool: Pool = {
    ...pool,
    totalDeposits: pool.totalDeposits + event.params.assets,
    updatedAt: BigInt(event.block.timestamp),
  };

  context.Pool.set(updatedPool);

  // Create deposit event
  const depositEvent: Pool_Deposit = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    pool_id: event.params.poolAddress,
    sender: event.params.sender,
    owner: event.params.owner,
    assets: event.params.assets,
    shares: event.params.shares,
    blockNumber: event.block.number,
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.Pool_Deposit.set(depositEvent);
});
```

## Validation Commands

After each change:

1. `pnpm codegen` - Regenerate types after schema changes
2. `pnpm tsc --noEmit` - Check TypeScript compilation
3. `TUI_OFF=true pnpm dev` - Test runtime behavior

## Error Handling

Always include proper error handling:

```typescript
OrderBook.OrderInserted.handler(async ({ event, context }) => {
  try {
    // Implementation here
  } catch (error) {
    context.log.error(`Error in OrderInserted handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```
