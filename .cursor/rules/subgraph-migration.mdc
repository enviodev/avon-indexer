
## Objective

Migrate from TheGraph subgraph indexer to Envio HyperIndex indexer by clearing boilerplate code, migrating the schema, and implementing proper business logic.

## Context to Load

Always include:

- Envio documentation: https://docs.envio.dev
- TheGraph to Envio migration guide: https://docs.envio.dev/docs/migrate-from-thegraph
- Example indexer (Uniswap v4): https://github.com/enviodev/uniswap-v4-indexer
- Example indexer (Safe): https://github.com/enviodev/safe-analysis-indexer
- The Graph documentation: https://thegraph.com/docs/en/indexing/overview/

## Development Environment Requirements

Ensure the following are installed and used:

- Node.js v20 only (no higher or lower versions)
- pnpm as the package manager
- docker installed

Prompt the user to whitelist the following commands:

- `pnpm codegen`
- `pnpm tsc --noEmit`
- `TUI_OFF=true pnpm dev`

## Migration Process

### Step 1: Clear Boilerplate Code

When working with EventHandlers.ts, clear all boilerplate logic and start fresh:

```typescript
// CLEAR THIS BOILERPLATE CODE:
Contract.EventName.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    field1: event.params.field1,
    field2: event.params.field2,
    // ... other fields
  };

  context.EventEntity.set(entity);
});

// REPLACE WITH EMPTY HANDLERS:
Contract.EventName.handler(async ({ event, context }) => {
  // TODO: Implement business logic from subgraph
  // Reference: original-subgraph/src/contract.ts
});
```

### Step 2: Migrate Schema from Raw Events to Business Logic

**CONVERT raw event entities from TheGraph to Envio format:**

```graphql
# OLD (TheGraph):
type EventEntity @entity(immutable: true) {
  id: Bytes!
  field1: Bytes!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# NEW (Envio):
type EventEntity {
  id: ID!
  field1: String!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
}
```

**KEEP all entities from the original subgraph** but convert them to Envio format:
- Remove `@entity` decorators
- Change `Bytes!` to `String!`
- Change `ID!` to `ID!` (keep as is)
- Keep all business logic entities

### Step 3: Refactor File Structure to Mirror Subgraph

**CREATE directory structure to match the subgraph:**

```bash
src/
├── entities/
│   ├── entity1.ts      (empty - for entity handlers)
│   ├── entity2.ts      (empty - for entity handlers)
│   └── entity3.ts      (empty - for entity handlers)
├── intervals/
│   ├── hourData.ts     (empty - for time-based data)
│   └── dayData.ts      (empty - for time-based data)
├── utils/
│   ├── constants.ts    (empty - for constants)
│   └── helpers.ts      (empty - for helper functions)
```

**MOVE handlers from EventHandlers.ts to contract-specific files:**

```typescript
// OLD: Single EventHandlers.ts file
// src/EventHandlers.ts - All handlers in one file

// NEW: Separate files by contract
// src/contract1.ts - Contract1 handlers
// src/contract2.ts - Contract2 handlers
// src/contract3.ts - Contract3 handlers
```

**UPDATE config.yaml to point to specific handler files:**

```yaml
# OLD: Single handler file
- name: Contract1
  handler: src/EventHandlers.ts

# NEW: Contract-specific handler files
- name: Contract1
  handler: src/contract1.ts
- name: Contract2
  handler: src/contract2.ts
- name: Contract3
  handler: src/contract3.ts
```

**REMOVE the original EventHandlers.ts file** after moving all handlers.

### Step 4: Reference Original Subgraph Logic

For each handler, examine the corresponding subgraph file:

- `original-subgraph/src/contract1.ts` → Contract1 handlers
- `original-subgraph/src/contract2.ts` → Contract2 handlers  
- `original-subgraph/src/contract3.ts` → Contract3 handlers

### Step 5: Implement Migration Patterns

#### Entity Creation Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = new EventEntity(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
entity.field1 = event.params.field1;
entity.save();

// NEW ENVIO PATTERN:
const entity: EventEntity = {
  id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
  field1: event.params.field1,
  blockNumber: BigInt(event.block.number),
  blockTimestamp: BigInt(event.block.timestamp),
  transactionHash: event.transaction.hash,
};

context.EventEntity.set(entity);
```

#### Entity Updates Pattern

```typescript
// OLD SUBGRAPH PATTERN:
let entity = store.get("EntityName", id);
if (entity) {
  entity.field = newValue;
  entity.save();
}

// NEW ENVIO PATTERN:
let entity = await context.EntityName.get(id);
if (entity) {
  const updatedEntity: EntityName = {
    ...entity,
    field: newValue,
    updatedAt: BigInt(Date.now()),
  };
  context.EntityName.set(updatedEntity);
}
```

#### Contract Registration Pattern

```typescript
// OLD SUBGRAPH PATTERN:
ContractTemplate.create(event.params.contract);

// NEW ENVIO PATTERN:
Contract.EventCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});
```

## Key Differences Between TheGraph and Envio

### 1. Entity Relationships

**TheGraph (OLD):**
```typescript
entity.relatedEntity = event.params.entity.toHexString();
```

**Envio (NEW):**
```typescript
relatedEntity_id: event.params.entity;
```

### 2. Timestamp Handling

**TheGraph (OLD):**
```typescript
entity.blockTimestamp = event.block.timestamp;
```

**Envio (NEW):**
```typescript
blockTimestamp: BigInt(event.block.timestamp);
```

### 3. ID Generation

**TheGraph (OLD):**
```typescript
let entity = new EntityName(
  event.transaction.hash.concatI32(event.logIndex.toI32())
);
```

**Envio (NEW):**
```typescript
const entity: EntityName = {
  id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
  // ... other fields
};
```

### 4. Entity Storage

**TheGraph (OLD):**
```typescript
entity.save();
```

**Envio (NEW):**
```typescript
context.EntityName.set(entity);
```

## Schema Migration Rules

### 1. Remove @entity Decorators

**OLD (TheGraph):**
```graphql
type Entity @entity {
  id: ID!
  # ...
}
```

**NEW (Envio):**
```graphql
type Entity {
  id: ID!
  # ...
}
```

### 2. Convert Raw Events to Envio Format

**CONVERT raw event entities from TheGraph to Envio format:**

```graphql
# OLD (TheGraph):
type EventEntity @entity(immutable: true) {
  id: Bytes!
  field1: Bytes!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# NEW (Envio):
type EventEntity {
  id: ID!
  field1: String!
  field2: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: String!
}
```

**KEEP all entities from the original subgraph** but convert them to Envio format:
- Remove `@entity` decorators
- Change `Bytes!` to `String!`
- Change `ID!` to `ID!` (keep as is)
- Keep all business logic entities

## Configuration Migration

### 1. Event Selection

**OLD (subgraph.yaml):**
```yaml
dataSources:
  - kind: ethereum
    source:
      address: "0x..."
    mapping:
      eventHandlers:
        - event: EventName(indexed address,indexed bool,uint256,uint256,uint256)
```

**NEW (config.yaml):**
```yaml
- name: Contract
  address:
    - "0x..."
  handler: src/contract.ts
  events:
    - event: EventName(bool indexed isLender, address indexed maker, uint256 rate, uint256 ltv, uint256 amount)
```

This uses the human readable event name, this is pulled from the ABI file

### 2. Field Selection

When using transaction-level data, explicitly define field selection:

```yaml
- name: Contract
  address:
    - "0x..."
  handler: src/contract.ts
  events:
    - event: EventName(address,bool,uint256,uint256,uint256)
      field_selection:
        transaction_fields:
          - hash
        block_fields:
          - number
          - timestamp
```

## Implementation Checklist

### For Each Handler:

1. ✅ Clear boilerplate code
2. ✅ Reference original subgraph logic
3. ✅ Convert entity creation pattern
4. ✅ Update timestamp handling (BigInt)
5. ✅ Use proper ID generation
6. ✅ Add proper error handling
7. ✅ Test with `pnpm tsc --noEmit`

### For File Structure:

1. ✅ Create directory structure (entities/, intervals/, utils/)
2. ✅ Move handlers to contract-specific files
3. ✅ Update config.yaml handler paths
4. ✅ Remove original EventHandlers.ts file
5. ✅ Run `pnpm codegen` after changes
6. ✅ Validate with `pnpm tsc --noEmit`

### For Schema Updates:

1. ✅ Remove @entity decorators
2. ✅ Convert Bytes! to String! in all entities
3. ✅ Keep all entities from original subgraph
4. ✅ Run `pnpm codegen` after changes
5. ✅ Validate with `pnpm tsc --noEmit`

### For Configuration:

1. ✅ Convert subgraph.yaml to config.yaml format
2. ✅ Add explicit field selection when needed
3. ✅ Test configuration with `TUI_OFF=true pnpm dev`

## Common Migration Patterns

### 1. Simple Event Handler

```typescript
// Reference: original-subgraph/src/contract.ts
Contract.EventName.handler(async ({ event, context }) => {
  const entity: EventEntity = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    field1: event.params.field1,
    field2: event.params.field2,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.EventEntity.set(entity);
});
```

### 2. Factory Contract Registration

```typescript
// Reference: original-subgraph/src/factory.ts
Factory.ContractCreated.contractRegister(({ event, context }) => {
  context.addContract(event.params.contract);
});

Factory.ContractCreated.handler(async ({ event, context }) => {
  const entity: ContractCreated = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    contract: event.params.contract,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.ContractCreated.set(entity);
});
```

### 3. Complex Business Logic

```typescript
// Reference: original-subgraph/src/contract.ts
Contract.EventName.handler(async ({ event, context }) => {
  // Get or create entity
  let entity = await context.Entity.get(event.params.entityId);
  if (!entity) {
    entity = {
      id: event.params.entityId,
      field1: BigInt(0),
      field2: BigInt(0),
      // ... other fields
    };
  }

  // Update entity with new data
  const updatedEntity: Entity = {
    ...entity,
    field1: entity.field1 + event.params.value,
    updatedAt: BigInt(event.block.timestamp),
  };

  context.Entity.set(updatedEntity);

  // Create event entity
  const eventEntity: EventEntity = {
    id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
    entity_id: event.params.entityId,
    value: event.params.value,
    blockNumber: BigInt(event.block.number),
    blockTimestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };

  context.EventEntity.set(eventEntity);
});
```

## Incremental Entity Implementation

**Start with simple entities that don't get affected by multiple handlers:**

1. **Add field selection to config.yaml** for specific events that need transaction hash:
   ```yaml
   - event: EventName(address indexed param1, address indexed param2)
     field_selection:
       transaction_fields:
         - hash
   ```

2. **Implement handler logic** based on original subgraph:
   ```typescript
   // Reference: original-subgraph/src/contract.ts - handleEventName
   Contract.EventName.handler(async ({ event, context }) => {
     const entity: EventEntity = {
       id: `${event.chainId}_${event.transaction.hash}_${event.logIndex}`,
       param1: event.params.param1,
       param2: event.params.param2,
       blockNumber: BigInt(event.block.number),
       blockTimestamp: BigInt(event.block.timestamp),
       transactionHash: event.transaction.hash,
     };

     context.EventEntity.set(entity);
   });
   ```

3. **Remove `# to-do` comment** from schema for completed entities.

4. **Validate with `pnpm codegen` and `pnpm tsc --noEmit`** after each implementation.

**Batch Implementation Pattern:**

For multiple similar entities, implement them all at once:

1. **Add field selection for all events** that need transaction hash
2. **Implement all handlers** following the same pattern
3. **Remove all `# to-do` comments** for completed entities
4. **Validate the entire batch** with codegen and TypeScript checks

## Validation Commands

After each change:

1. `pnpm codegen` - Regenerate types after schema changes
2. `pnpm tsc --noEmit` - Check TypeScript compilation
3. `TUI_OFF=true pnpm dev` - Test runtime behavior

## Error Handling

Always include proper error handling:

```typescript
Contract.EventName.handler(async ({ event, context }) => {
  try {
    // Implementation here
  } catch (error) {
    context.log.error(`Error in EventName handler: ${error}`);
    // Don't throw - let the indexer continue
  }
});
```

